<!DOCTYPE html>
<html>
	<head>
		<title>three.terraingen.js</title>
		<style type="text/css">
			
			html, body {
				padding:0;
				margin:0;
				overflow:hidden;
			}
			
			#heightMap {
				position:absolute;
				top:10px;
				left:10px;
			}
			
			#controls {
				position:absolute;
				right:10px;
				top:10px;
				padding:20px;
				background:rgba(255,255,255,0.7);
				z-index:100;
			}
		</style>
	</head>
	
	<body>
		
		<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.js"></script>
		<script type="text/javascript" src="../dist/libs/catiline.js"></script>
		<script type="text/javascript" src="../dist/RNGProvider.js"></script>
		<script type="text/javascript" src="../dist/NoiseProvider.js"></script>
		<script type="text/javascript" src="../dist/NoiseModifierProvider.js"></script>
		<script type="text/javascript" src="../dist/HeightMapProvider.js"></script>
		<script type="text/javascript" src="../dist/GeometryProvider.js"></script>
		<script type="text/javascript" src="../dist/MeshProvider.js"></script>
		<script type="text/javascript" src="../dist/PatchProvider.js"></script>
		<script type="text/javascript" src="../dist/FilterProvider.js"></script>
		<script type="text/javascript" src="ThreadedThings.js"></script>
		<script type="text/javascript" src="TrackBallControls.js"></script>
		<script type="text/javascript" src="OrbitControls.js"></script>
		
		<script type="text/javascript">
		
			/*
			 * Define a Noise Function by mixing together various generators and modifiers
			 * to give us something more interesting than the standard perlin noise
			 */
			var noiseFunction = new THREE.terraingen.modifiers.Multiply (
				new THREE.terraingen.modifiers.Mix (
					new THREE.terraingen.modifiers.Constant(1.0),
					new THREE.terraingen.modifiers.Multiply(
						new THREE.terraingen.modifiers.Abs(
							new THREE.terraingen.modifiers.Invert (
								new THREE.terraingen.generators.Perlin (
									new THREE.terraingen.MersenneTwisterProvider(98908124324432).random, 12, 0.00012
								)
							)
						),
						new THREE.terraingen.modifiers.Constant( 1.4 )
					),
					new THREE.terraingen.modifiers.Multiply(
						new THREE.terraingen.generators.Perlin (
							new THREE.terraingen.MersenneTwisterProvider(3335).random, 3, 0.00015
						),
						new THREE.terraingen.modifiers.Constant (
							0.8
						)
					)
				),
				new THREE.terraingen.modifiers.Constant(1.2)
			)
			
			
			/*
			 * Assign this to the global terrain worker
			 */
			TerrainWorker.noiseGenerator = noiseFunction;
			
			/*
			 * Pass the terrain worker to catiline to run in threads
			 */
			workers = cw(TerrainWorker, 8);
			
			
			/*
			 * Lets setup some numbers
			 */
			
			// The siz in world units of each tile
			var TILE_SIZE = 2048;
			
			// Number of tiles to pre-generate
			var NUM_TILES = 8;
			
			// Number of vertices per side of each tile
			var SEGMENTS = 64;
			
			// Total number of vertices we're going to put in the scene
			var NUM_VERTS = SEGMENTS * SEGMENTS * 3;
			
			// Let's see what that is
			console.log ("total verts = ", NUM_VERTS * NUM_TILES);
			
			// A queue in which completed tiles are put to be added to the scene
			var buildQueue = [];
			
			// the point at which to start building tiles
			var origin = -((NUM_TILES * TILE_SIZE) / 2);
			
			// 2D world center
			var center = new THREE.Vector2(0,0);
			
			// The array of tiles to build
			var tiles = [];
			
			
			// Create the basic THREE.js scene
			var scene, renderer, camera, controls;
			function createScene () {
				 	camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 18000);
			 		camera.position.z = 2000;
			 		camera.position.x = 2000;
			 		camera.position.y = 4000;
			 		scene = new THREE.Scene();
			 		renderer = new THREE.WebGLRenderer();
			 		renderer.setSize( window.innerWidth, window.innerHeight );
			 		document.body.appendChild(renderer.domElement);
			 		controls = new THREE.OrbitControls(camera);
			}
			createScene()
			
			/*
			 * A function to take completed tiles and build them into THREE.js buffergeometries
			 */
			function buildGeometry (data) {
				var indices = new ( ( data.vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( data.segments * data.segments * 6 );
				var seg1 = data.segments+1;
				var offset = 0;
				for (var iy=0; iy<data.segments; iy++) {
					for (var ix=0; ix<data.segments; ix++) {
						var a = ix + seg1 * iy;
						var b = ix + seg1 * ( iy + 1 );
						var c = ( ix + 1 ) + seg1 * ( iy + 1 );
						var d = ( ix + 1 ) + seg1 * iy;
			
						indices[ offset     ] = a;
						indices[ offset + 1 ] = b;
						indices[ offset + 2 ] = d;
			
						indices[ offset + 3 ] = b;
						indices[ offset + 4 ] = c;
						indices[ offset + 5 ] = d;
			
						offset += 6; 
					}
				}
				
				var geom = new THREE.BufferGeometry();
				geom.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ));
				geom.addAttribute( 'position', new THREE.BufferAttribute( data.vertices, 3 ) );
				geom.computeFaceNormals();
			    geom.computeVertexNormals(true);
				var material = new THREE.MeshNormalMaterial();
				var mesh = new THREE.Mesh(geom, material);
				scene.add(mesh);
				mesh.position.x = data.bounds.min.x;
				mesh.position.z = data.bounds.min.y;
			}
			
			
			
			/*
			 * Fill up an initial array of tiles to build
			 */
			for (var i=0; i<NUM_TILES; i++ ) {
				
				var _x = origin + (i * TILE_SIZE);

				for (var j=0; j<NUM_TILES; j++) {
					
					var _y = origin + (j * TILE_SIZE);
					
					var bounds = new THREE.Box2( new THREE.Vector2( _x, _y ), new THREE.Vector2( _x + TILE_SIZE, _y + TILE_SIZE ) );
					var dist = center.distanceTo(bounds.center());
					
					var params = {
						bounds: bounds,
						distance: dist,
						segments: SEGMENTS,
						octaves:12,
						scale:0.005,
						seed:623424322,
						vertices: new Float32Array ( (SEGMENTS + 1) * (SEGMENTS+1) * 3 )
					}
					tiles.push (params);
				}
			}
			
			/*
			 * Sort them by distance to the camera ( TODO: This doesn't seem to affect build order )
			 */
			tiles = tiles.sort(function (a, b) {
				if (a.dist < b.dist) {
					return -1;
				} else if (a.dist > b.dist) {
					return 1;
				} else {
					return 0;
				}
			});
			
			/*
			 * Push the tiles to the workers to process
			 */
			for (var i=0; i<tiles.length; i++ ) {
				workers.getVertices(tiles[i]).then( function (data) {
					buildQueue.push(data);
				}, function (err) {
					console.log(err);
				});
			}

			/*
			 * Standard THREE.js update and render loop
			 */
			function animate () {
		 		requestAnimationFrame(animate);
		 		if (buildQueue.length) {
		 			buildGeometry(buildQueue.pop())
		 		}
		 		controls.update();
		 		render();
		 	}
			
		 	
		 	function render () {
		 		var time = Date.now() * 0.001;
				renderer.render( scene, camera );
		 	}
			
			/*
			 * Off we go!
			 */
			animate();
			
			
		</script>
		
		
	</body>
</html>