<!DOCTYPE html>
<html>
	<head>
		<title>three.terraingen.js</title>
		<style type="text/css">
			
			html, body {
				padding:0;
				margin:0;
				overflow:hidden;
			}
			
			#heightMap {
				position:absolute;
				top:10px;
				left:10px;
			}
			
			#controls {
				position:absolute;
				right:10px;
				top:10px;
				padding:20px;
				background:rgba(255,255,255,0.7);
				z-index:100;
			}
		</style>
	</head>
	
	<body>
		<div id="controls">
			<label>Seed</label>
			<input type="text" id="seed" value="545437820543">
			<br>
			<label>X</label>
			<input type="range" id="pos_x" min="0" max="10000" value="0">
			<label>Y</label>
			<input type="range" id="pos_y" min="0" max="10000" value="0">
		</div>
		
		<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.js"></script>
		<script type="text/javascript" src="../dist/libs/catiline.js"></script>
		<script type="text/javascript" src="../dist/RNGProvider.js"></script>
		<script type="text/javascript" src="../dist/NoiseProvider.js"></script>
		<script type="text/javascript" src="../dist/NoiseModifierProvider.js"></script>
		<script type="text/javascript" src="../dist/HeightMapProvider.js"></script>
		<script type="text/javascript" src="../dist/GeometryProvider.js"></script>
		<script type="text/javascript" src="../dist/MeshProvider.js"></script>
		<script type="text/javascript" src="../dist/PatchProvider.js"></script>
		<script type="text/javascript" src="../dist/FilterProvider.js"></script>
		<script type="text/javascript" src="ThreadedThings.js"></script>
		<script type="text/javascript" src="TrackBallControls.js"></script>
		<script type="text/javascript" src="OrbitControls.js"></script>
		
		<script type="text/javascript">
		
			//NoiseGenerator.Seed = 523542354534543;
			
			NoiseGenerator.initRandom(33);
			
			
			
			
			
			var noiseFunction = new THREE.terraingen.modifiers.Multiply (
				new THREE.terraingen.modifiers.Mix (
					/*new THREE.terraingen.modifiers.Min (
						new THREE.terraingen.generators.Perlin (
							new THREE.terraingen.MersenneTwisterProvider(1222).random, 16, 0.001
						),
						new THREE.terraingen.modifiers.Constant( 0.3 )
					),*/
					
					new THREE.terraingen.modifiers.Constant(-1),
					
					new THREE.terraingen.modifiers.Invert(
						new THREE.terraingen.modifiers.Abs (
							new THREE.terraingen.generators.Perlin (
								new THREE.terraingen.MersenneTwisterProvider(32).random, 12, 0.00015
							)
						)
					),
					
					new THREE.terraingen.generators.Perlin (
						new THREE.terraingen.MersenneTwisterProvider(3335).random, 4, 0.0001
					)
				
				),
				
				new THREE.terraingen.modifiers.Constant(2.0)
			)
			
			NoiseGenerator.noiseGenerator = noiseFunction;
			
			workers = cw(NoiseGenerator, 10);
			
			var NOISE_SIZE = 512;
			var NUM_TILES = 8;
			
			
			
			function renderCanvas (noiseResult, x, y) {
				
				
				var canvas = document.createElement('canvas');
				canvas.height = NOISE_SIZE;
		 		canvas.width = NOISE_SIZE;
		 		
		 		canvas.style.position = "absolute";
		 		canvas.style.top = y + "px";
		 		canvas.style.left = x + "px";
		 		
		 		document.body.appendChild(canvas);
		 		
		 		
		 		
		 		var ctx = canvas.getContext('2d')
		 		var id = ctx.createImageData(1,1);
		 		var d = id.data;
		 		
		 		
		 		for (var i = 0; i < NOISE_SIZE; i++) {
		 			for (var j = 0; j < NOISE_SIZE; j++) {
		 				
		 				var hgt = noiseResult[ i*NOISE_SIZE + j ]
		 				h = hgt + 1.0 * 0.5;
		 				var pix = Math.min(255, Math.max(0, Math.floor( (h) * 256 )));
		 				d[0] = d[1] = d[2] = pix;
		 				d[3] = 255;
		 				ctx.putImageData(id, i, j);
		 			}
		 		}
		 		
		 		
			}
			
			
			var queue = [];
			
			function doIt (posx, posy) {
				
				
				var px = posx;
				var py = posy;
				
				
				var canvases = document.getElementsByTagName('canvas');
				
				for (var i=0; i<canvases.length; i++) {
					document.body.removeChild(canvases[i]);
				}
				
				for (var i=0; i<NUM_TILES; i++ ) {
					for (var j=0; j<NUM_TILES; j++) {
						var params = {
							
							x_screen: i*NOISE_SIZE,
							y_screen: j*NOISE_SIZE,
							
							x:posx + (i*NOISE_SIZE), 
							y:posy + (j*NOISE_SIZE), 
							width:NOISE_SIZE, 
							height:NOISE_SIZE, 
							octaves:10, 
							scale:1.0, 
							seed:424324,
							container: new Float32Array( NOISE_SIZE * NOISE_SIZE )
						}
						workers.getRegion(params).then(
							function (data) {
								queue.push( data )
							}, 
							function (err) {
								console.log(err)
							}
						);
					}
				}
			}
			
			
			
			function update () {
				requestAnimationFrame(update);
				if (queue.length) {
					var d = queue.pop();
					renderCanvas( d.container, d.x_screen, d.y_screen )
				}
			}
			
			var inptX = document.getElementById('pos_x');
			var inptY = document.getElementById('pos_y');
			
			var btn = document.getElementById('btn_go');
			
			inptX.onchange = inptY.onchange = function () {
				var _x = parseInt ( inptX.value );
				var _y = parseInt ( inptY.value );
				doIt(_x,_y);
			}
			
			
			
			/*inpt.onkeyup = function () {
				var scale = getScale(scaleinpt.value)
				doIt(this.value, scale);
			}*/
			
			
			/*scaleinpt.onchange = function () {
				var seed = inpt.value
				doIt( seed, getScale( this.value ));
			}*/
			
			update();
			
			// test vertices
			
			
			
			
			var prams = {
				bounds: new THREE.Box2( new THREE.Vector2( 0, 0 ), new THREE.Vector2( 128, 128 ) ),
				segments: 33,
				octaves:12,
				scale:0.005,
				seed:623424322,
				vertices: new Float32Array ( 33 * 33 * 3 )
			}
			

			
			var scene, renderer, camera, controls;
			
			function createScene () {
				 	camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 13000);
			 		camera.position.z = 500
			 		camera.position.y = 4000
			 		//camera.lookAt = new THREE.Vector3(800,0,1000)
			 		
			 		scene = new THREE.Scene();
			 		
			 		//scene.add( new THREE.AmbientLight( 0x444444 ));
			 		
			 		renderer = new THREE.WebGLRenderer();
			 		
			 		renderer.setSize( window.innerWidth, window.innerHeight );
			 		
			 		document.body.appendChild(renderer.domElement);
			 		
			 		controls = new THREE.OrbitControls(camera);
				
			}
			
			
			createScene()
			
			var SEGMENTS = 128;
			
			var NUM_VERTS = SEGMENTS * SEGMENTS * 3;
			
			console.log ("total verts = ", NUM_VERTS * NUM_TILES);
			
			var buildQueue = [];
			
			function buildGeometry (data) {
				var indices = new ( ( data.vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( data.segments * data.segments * 6 );
				var seg1 = data.segments+1;
				var offset = 0;
				for (var iy=0; iy<data.segments; iy++) {
					for (var ix=0; ix<data.segments; ix++) {
						var a = ix + seg1 * iy;
						var b = ix + seg1 * ( iy + 1 );
						var c = ( ix + 1 ) + seg1 * ( iy + 1 );
						var d = ( ix + 1 ) + seg1 * iy;
			
						indices[ offset     ] = a;
						indices[ offset + 1 ] = b;
						indices[ offset + 2 ] = d;
			
						indices[ offset + 3 ] = b;
						indices[ offset + 4 ] = c;
						indices[ offset + 5 ] = d;
			
						offset += 6; 
					}
				}
				
				
				var geom = new THREE.BufferGeometry();
				geom.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ));
				geom.addAttribute( 'position', new THREE.BufferAttribute( data.vertices, 3 ) );
				
				
				geom.computeFaceNormals();
			    geom.computeVertexNormals(true);
				var material = new THREE.MeshNormalMaterial();
				var mesh = new THREE.Mesh(geom, material);
				
				scene.add(mesh);
				mesh.position.x = data.bounds.min.x;
				mesh.position.z = data.bounds.min.y;
			}
			
			
			var origin = -((NUM_TILES * NOISE_SIZE) / 2);
			
			for (var i=0; i<NUM_TILES; i++ ) {
					
					var _x = origin + (i * NOISE_SIZE);
					
					for (var j=0; j<NUM_TILES; j++) {
						
						var _y = origin + (j * NOISE_SIZE);
						
						var params = {
							bounds: new THREE.Box2( new THREE.Vector2( _x, _y ), new THREE.Vector2( _x + NOISE_SIZE, _y + NOISE_SIZE ) ),
							segments: SEGMENTS,
							octaves:12,
							scale:0.005,
							seed:623424322,
							vertices: new Float32Array ( (SEGMENTS + 1) * (SEGMENTS+1) * 3 )
						}
						workers.getVertices(params).then( function (data) {
							buildQueue.push(data);
						}, function (err) {
							console.log(err);
						});
					}
				}
			
			
			
			function animate () {
		 		requestAnimationFrame(animate);
		 		if (buildQueue.length) {
		 			buildGeometry(buildQueue.pop())
		 		}
		 		controls.update();
		 		render();
		 	}
			
		 	
		 	function render () {
		 		var time = Date.now() * 0.001;
		
				
				//mesh.rotation.y = time * 0.2;
		 		
				
				renderer.render( scene, camera );
		 	}
			
			animate();
			
			
		</script>
		
		
	</body>
</html>